
function [c, rings] = k_recovery(uw, mask, freqvec, spacing)

%% set parameters

% for z denoise 
z_lev = 3;
NORM = 0.5;
% for log-gabor bank
sig_r = 0.7;
sig_t = 0.3;
lam_min = 3;
num_scales = 4;
mult = 2.1;
w = zeros(num_scales, 1)';
for scale = 1:num_scales
    lam = lam_min * mult^(scale-1);
    w(scale) = 1 / lam;
end
rings = cell(num_scales,1);
num_theta = 8;
num_phi = 4;
% for wavelet bank
[Faf, Fsf] = FSfarras;
[af, sf] = dualfilt1;
J = 2;
% for phase gradient recovery
W = 4;

% reshape and allocate data
[U, nvols] = resh(uw, 4);
weightedK = zeros(size(U(:,:,:,1));


%% strip interslice artifact
disp('Interslice artifact removal...');
tic
parfor n = 1:nvols
    U(:,:,:,n) = zden_3D_DWT(dejitter_phase_mask(U(:,:,:,n), mask, NORM), z_lev, mask);
end
toc

%% wavelet decomposition of image
disp('Simultanous decomposition, denoise, directional filter')
for v = 1:nvols
    % blind noise estimation
    sigma = sigma_mad_wavelet(U(:,:,:,v));
    % undecimated directional complex wavelet decomposition
    w = cplxdual3D_u(U(:,:,:,v), J, Faf, af);
    % denoise wavelet coefficients with nonnegative garotte
    w = denoise_wavelet_coefficients(w, sigma);
    % convolve scaling images with log-gabor filter bank. estimate weighted
    % k and weights
    for scale = 1:num_scales
        % create sample image of the freq scale, for inspection
        lg = loggabor_3d(size(w{J+1}{1}{1}{1}), w(scale),  -1, -1, SIG_R, SIG_ANG);
        sz = size(lg);
        rings{scale} = lg(:,:,ceil((sz(3)+1)/2); % center slice in odd, half plus one in even
        for theta = 1:num_theta
            disp(['--',num2str(theta)])
            for phi = 1:num_phi
                disp(['---',num2str(phi)])
                lg = loggabor_3d(size(w{J+1}{1}{1}{1}), scaler(scale),  theta*2*pi/ORS, phi*pi/SORS, SIG_R, SIG_ANG);
                U_filt = cplxdual3D_u(filter_and_scale(w, lg), J, Faf, af);
                weights = abs(U_filt).^W;
            end
        end
    end
end

end

function w = denoise_wavelet_coefficients(w, sigma)
    % denoise complex wavelet coefficients using nonnegative garotte
    for j = 1:J
        for m = 1:2
            for n = 1:2
                for p = 1:2
                    for q = 1:7
                        w_n = w{j}{m}{n}{p}{q};
                        w{j}{m}{n}{p} = nng(w_n, sigma);
                    end
                end
            end
        end
    end
end

function w_filt = filter_and_scale(w, lg)
    % filter scaling coefficients
    J = numel(w)-1;
    w_filt = w;
    for m = 1:2
        for n = 1:2
            for p = 1:2
                convn = fftshift(fftn(w{J+1}{m}{n}{p})).*lg;
                w_filt{J+1}{m}{n}{p} = ifftn(ifftshift(convn));
            end
        end
    end
    % scale wavelet coefficients
    for m = 1:2
        for n = 1:2
            for p = 1:2
                w_lo_orig = w{J+1}{m}{n}{p};
                w_lo_filt = w_filt{J+1}{m}{n}{p};
                ratio = range(abs(w_lo_filt(:))) ./ range(abs(w_lo_orig(:)));
                for q = 1:7
                    for j = 1:J
                        w_filt{j}{m}{n}{p}{q} = w_filt{j}{m}{n}{p}{q} .* ratio;
                    end
                end
            end
        end
    end
end

function absK = phase_gradient(u, spacing)
    dx = angle( conj(u(1:end-1,:,:)) .* u(2:end,:,:) ) / spacing(1);
    dy = angle( conj(u(:,1:end-1,:)) .* u(:,2:end,:) ) / spacing(2);
    dz = angle( conj(u(:,:,1:end-1)) .* u(:,:,2:end) ) / spacing(3);
    G1 = [dx(1,:,:); (dx(1:end-1,:,:)+dx(2:end,:,:)) / 2; dx(end,:,:)];
    G2 = [dy(:,1,:), (dy(:,1:end-1,:)+dy(:,2:end,:)) / 2, dy(:,end,:)];
    G3 = [dz(:,:,1), (dz(:,:,1:end-1)+dz(:,:,2:end)) / 2, dz(:,:,end)];
    absK = sqrt( abs(G1).^2 + abs(G2).^2 + abs(G3).^2);%[rad/m] real part of the wave vector k
end
  

